package main

import (
	"flag"
	"fmt"
	"net"
	"net/url"
	"os"
	"path/filepath"
)

func main() {
	var domain string
	var port string
	var outPath string
	flag.StringVar(&domain, "domain", "", "The domain to use for the generated URLs")
	flag.StringVar(&port, "port", "8080", "The port to use for the generated URLs")
	flag.StringVar(&outPath, "out", "", "Write TypeScript output to this file (default: stdout)")
	flag.Parse()

	if domain == "" {
		panic("domain is missing")
	}

	var host string
	var scheme string
	if domain == "localhost" {
		host = net.JoinHostPort(domain, port)
		scheme = "http"
	} else {
		host = domain
		scheme = "https"
	}

	baseUrl := &url.URL{Scheme: scheme, Host: host}

	out := baseUrl.String()

	//bareEndpoints, err := api.MakeBareEndpoints()
	//if err != nil {
	//	panic(fmt.Errorf("make bare endpoints: %w", err))
	//}
	//if bareEndpoints == nil {
	//	panic("bare endpoints is nil")
	//}
	//
	//out, err := client_code_generation.Render(
	//	[]*endpoint_specification.EndpointSpecification{
	//		bareEndpoints.GoogleEndpointSpecificationOverview.FedCmEndpoint,
	//	},
	//	baseUrl,
	//)
	//if err != nil {
	//	panic(fmt.Errorf("client code generation render: %w", err))
	//}

	typescriptOutput := fmt.Sprintf("// Code generated by typescript_generation; DO NOT EDIT.\n\n%s\n", out)

	if outPath != "" {
		if err := os.MkdirAll(filepath.Dir(outPath), 0o755); err != nil {
			panic(fmt.Errorf("creating typescript output dir: %w", err))
		}
		if err := os.WriteFile(outPath, []byte(typescriptOutput), 0o600); err != nil {
			panic(fmt.Errorf("writing typescript output: %w", err))
		}
	} else {
		fmt.Println(typescriptOutput)
	}
}
